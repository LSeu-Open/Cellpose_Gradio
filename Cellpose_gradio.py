import gradio as gr
import numpy as np
import os
from cellpose import models, utils
import matplotlib.pyplot as plt
from PIL import Image
from datetime import datetime
import json
from werkzeug.utils import secure_filename
########################################################
# 1. Utility functions
########################################################

def load_image(file_path: str) -> tuple[np.ndarray | None, str | None]:
    """
    Load an image file and return it as a numpy array.

    This function attempts to load an image from the specified file path,
    checking for file existence and supported file formats. It returns
    the image as a numpy array if successful, or None with an error message
    if unsuccessful.

    Args:
        file_path (str): The path to the image file to be loaded.

    Returns:
        tuple[np.ndarray | None, str | None]: A tuple containing:
            - The loaded image as a numpy array, or None if loading failed.
            - An error message string if an exception occurred, or None if successful.
    """
    valid_extensions = ['.tif', '.tiff', '.png', '.jpg', '.jpeg']
    
    try:
        if not os.path.exists(file_path):
            gr.Error(f"Image file not found: {file_path}")
            return None, f"Image file not found: {file_path}"
        
        if os.path.splitext(file_path)[1].lower() not in valid_extensions:
            gr.Error("Unsupported file format. Please use TIFF, PNG, or JPEG images.")
            return None, "Unsupported file format. Please use TIFF, PNG, or JPEG images."
        
        image = plt.imread(file_path)
        if image is None:
            gr.Error("Failed to load image")
            return None, "Failed to load image"
        
        return image, None
    except Exception as e:
        gr.Error(str(e))
        return None, str(e)

def count_cells(masks: np.ndarray) -> int:
    """
    Count the number of unique cells in a segmentation mask.

    This function takes a 2D numpy array of segmentation masks where each cell
    is labeled with a unique integer, and counts the number of distinct cells.
    It assumes that the background is labeled as 0.

    Args:
        masks (np.ndarray): A 2D numpy array containing segmentation masks.

    Returns:
        int: The number of unique cells in the mask.

    Note:
        This function subtracts 1 from the count to exclude the background,
        which is typically labeled as 0 in the mask.
    """
    return len(np.unique(masks)) - 1

def save_masks(image, masks):
    """
    Save the segmentation masks in various formats.

    This function saves the segmentation masks as NPY, PNG, and outline PNG files.
    It creates a unique filename for each output based on the current timestamp.

    Args:
        image (np.ndarray): The original input image.
        masks (np.ndarray): The segmentation masks generated by Cellpose.

    Returns:
        list: A list of absolute file paths for the saved masks (NPY, PNG, and outline PNG),
              or None if no masks were provided.

    Note:
        - The function creates an 'Outputs' folder if it doesn't exist.
        - The NPY file contains the raw mask data.
        - The PNG file shows the masks with a viridis colormap.
        - The outline PNG file shows the outlines of the masks overlaid on the original image.
    """
    if masks is not None:
        # Create a unique base filename using a formatted timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M")
        base_filename = f"cellpose_{timestamp}"
        
        # Save masks as NPY
        # Create Outputs folder if it doesn't exist
        output_folder = "Outputs"
        os.makedirs(output_folder, exist_ok=True)

        # Save masks as NPY
        npy_filename = os.path.join(output_folder, f"masks_{base_filename}.npy")
        np.save(npy_filename, masks)
        npy_path = os.path.abspath(npy_filename)

        # Save masks as PNG
        png_filename = os.path.join(output_folder, f"masks_{base_filename}.png")
        plt.figure(figsize=(10, 10))
        plt.imshow(masks, cmap='tab20b')
        plt.axis('off')
        plt.savefig(png_filename, bbox_inches='tight', pad_inches=0, dpi=300)
        plt.close()
        png_path = os.path.abspath(png_filename)

        # Save outlines as PNG
        outlines_filename = os.path.join(output_folder, f"outlines_{base_filename}.png")
        overlay = image.copy()
        overlay = utils.masks_to_outlines(masks)
        Image.fromarray(overlay).save(outlines_filename)
        outlines_path = os.path.abspath(outlines_filename)

        return [npy_path, png_path, outlines_path]
    return None

########################################################
# 2. Core processing functions
########################################################

def segment_image(image: np.ndarray, model_type: str, channels: list, diameter: float = None, flow_threshold: float = None) -> np.ndarray:
    """
    Segment cells in an image using the Cellpose model.

    This function applies the Cellpose segmentation algorithm to the input image
    using the specified model type and parameters. It returns a mask array where
    each cell is uniquely labeled.

    Args:
        image (np.ndarray): The input image to be segmented.
        model_type (str): The type of Cellpose model to use (e.g., 'cyto', 'nuclei').
        channels (list): List specifying the channels to use for segmentation.
        diameter (float, optional): The expected diameter of cells in pixels. Defaults to None.
        flow_threshold (float, optional): The flow threshold for cell detection. Defaults to None.

    Returns:
        np.ndarray: A 2D array of the same size as the input image, where each cell
                    is labeled with a unique integer. Background is labeled as 0.

    Raises:
        RuntimeError: If segmentation fails due to invalid input or parameters.
    """
    model = models.Cellpose(model_type=model_type)
    
    try:
        masks, _, _, _ = model.eval(image, channels=channels, diameter=diameter, flow_threshold=flow_threshold)
        return masks
    except Exception as e:
        raise RuntimeError(f"Segmentation failed: {str(e)}. Check your input image and parameters.")

def display_results(image: np.ndarray, masks: np.ndarray, display_channel: str, cmap: str = 'tab20b') -> plt.Figure:
    """
    Display the original image and segmentation masks side by side.

    This function creates a figure with three subplots: one for the original image,
    one for the segmentation masks and one for the outlines. The original image can be displayed
    in different modes (RGB, Grayscale, or individual color channels) based on
    the display_channel parameter.

    Args:
        image (np.ndarray): The original input image.
        masks (np.ndarray): The segmentation masks generated by Cellpose.
        display_channel (str): The channel to display for the original image.
            Can be "RGB", "Grayscale", "Red", "Green", or "Blue".
        cmap (str): The colormap to use for displaying the segmentation masks.

    Returns:
        plt.Figure: A matplotlib Figure object containing the three subplots.

    Note:
        The function uses different colormaps for the original image (grayscale
        for single-channel displays) and the segmentation masks (user-specified).
    """
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 6))
    
    # Display original image
    if display_channel == "RGB":
        ax1.imshow(image)
    elif display_channel == "Grayscale":
        ax1.imshow(np.mean(image, axis=2), cmap='gray')
    elif display_channel in ["Red", "Green", "Blue"]:
        channel_index = {"Red": 0, "Green": 1, "Blue": 2}[display_channel]
        ax1.imshow(image[:,:,channel_index], cmap='gray')
    else:
        ax1.imshow(image)
    ax1.set_title('Original Image')
    ax1.axis('off')
    
    # Display segmentation masks
    ax2.imshow(masks, cmap=cmap)
    ax2.set_title('Segmentation Masks')
    ax2.axis('off')
    ax2.set_facecolor('black')
    
    # display masks outlines
    outlines = utils.masks_to_outlines(masks)
    ax3.imshow(outlines, cmap='gray')
    ax3.set_title('Outlines')
    ax3.axis('off')
    ax3.set_facecolor('black')

    plt.tight_layout()
    return fig

########################################################
# 3. Gradio-specific functions
########################################################

def process_and_display(image, model_type, diameter, flow_threshold, display_channel, seg_channel1, seg_channel2, cmap, progress=gr.Progress()):
    """
    Process an input image using Cellpose for cell segmentation and display the results.

    This function performs the following steps:
    1. Checks if an image is provided and converts it to the appropriate format.
    2. Applies Cellpose segmentation using the specified parameters.
    3. Generates a figure displaying the segmentation results.
    4. Counts the number of cells in the segmented image.
    5. Saves the segmentation masks to files.

    Args:
        image (numpy.ndarray): Input image for segmentation.
        model_type (str): Type of Cellpose model to use ('cyto3', 'cyto2', or 'nuclei').
        diameter (int): Approximate diameter of cells in pixels.
        flow_threshold (float): Flow threshold for Cellpose segmentation.
        display_channel (str): Channel to display in the output figure.
        seg_channel1 (int): First channel to use for segmentation.
        seg_channel2 (int): Second channel to use for segmentation.
        cmap (str): Colormap to use for displaying the segmentation masks.
        progress (gr.Progress): Gradio progress indicator.

    Returns:
        tuple: Contains the following elements:
            - fig (matplotlib.figure.Figure): Figure object with segmentation results.
            - mask_files (list): Paths to saved mask files.
            - cell_count (int): Number of cells detected.
            - gr.update: Gradio update object to hide/show error alerts.
    """
    try:
        if image is not None:
            # Convert grayscale to RGB if necessary
            if image.ndim == 2:
                image = np.stack((image,) * 3, axis=-1)
            elif image.ndim == 3 and image.shape[2] == 4:  # RGBA image
                image = image[:, :, :3]  # Remove alpha channel
            
            # Ensure image is uint8
            image = (image * 255).astype(np.uint8) if image.dtype == np.float64 else image.astype(np.uint8)
            
            # Set channels for segmentation
            progress(0.1, desc="Segmentation starting...")
            channels = [seg_channel1, seg_channel2]
            
            progress(0.25, desc="Segmentation in progress...")
            masks = segment_image(image, model_type, channels=channels, diameter=diameter, flow_threshold=flow_threshold)
            progress(0.75, desc="Segmentation complete. Generating results...")
            
            fig = display_results(image, masks, display_channel=display_channel, cmap=cmap)
            cell_count = count_cells(masks)
            mask_files = save_masks(image, masks)
            
            progress(1.0, desc="Process complete!")
            return fig, mask_files, cell_count, gr.update(visible=False)
        gr.Error("No image provided.")
        return None, None, None, gr.update(visible=True)
    
    except Exception as e:
        gr.Error(str(e))  # Show error message
        return None, None, None, gr.update(visible=True)

def update_channel_visibility(channel_config):
    """
    Update the visibility of segmentation channels based on the selected configuration.

    This function takes a channel configuration string and returns visibility updates
    for two segmentation channels. If the configuration is "own channels", both channels
    are made visible. Otherwise, both channels are hidden.

    Args:
        channel_config (str): The channel configuration string. Expected values are "own channels" or other.

    Returns:
        tuple: A tuple containing two gr.update objects to set the visibility of the segmentation channels.
    """
    if channel_config == "own channels":
        return gr.update(visible=True), gr.update(visible=True)
    else:
        return gr.update(visible=False), gr.update(visible=False)

def save_settings(profile_name, model_type, diameter, flow_threshold, display_channel, seg_channel1, seg_channel2, cmap):
    """
    Save the current settings to a JSON file with a specific profile name and refresh the profile list.
    """
    # Create a dictionary with the provided settings
    settings = {
        "model_type": model_type,
        "diameter": diameter,
        "flow_threshold": flow_threshold,
        "display_channel": display_channel,
        "seg_channel1": seg_channel1,
        "seg_channel2": seg_channel2,
        "cmap": cmap
    }
    
    # Create a 'profiles' directory if it doesn't exist
    profiles_dir = "profiles"
    os.makedirs(profiles_dir, exist_ok=True)
    
    # Ensure the profile name is safe to use as a filename
    safe_profile_name = secure_filename(profile_name)
    if not safe_profile_name:
        raise ValueError("Invalid profile name")
    
    # Construct the full path
    full_path = os.path.join(profiles_dir, f"{safe_profile_name}.json")
    
    # Save the settings to a JSON file named after the profile
    with open(full_path, "w") as f:
        json.dump(settings, f)
    
    gr.Info(f"Settings saved successfully as profile: {profile_name}")
    
    # Return the updated list of profiles
    return gr.update(choices=list_profiles(), value=safe_profile_name)

def list_profiles():
    """
    List all available profiles in the 'profiles' directory.
    """
    base_path = "profiles"
    if not os.path.exists(base_path):
        return []
    return [f.split('.')[0] for f in os.listdir(base_path) if f.endswith('.json')]

def load_settings(profile_name):
    """
    Load settings from a specific profile JSON file.
    """
    file_path = f"profiles/{profile_name}.json"
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            settings = json.load(f)
        gr.Info(f"Settings loaded successfully from profile: {profile_name}")
        return (settings["model_type"], settings["diameter"], settings["flow_threshold"], 
                settings["display_channel"], settings["seg_channel1"], settings["seg_channel2"], 
                settings["cmap"])
    gr.Warning(f"Profile '{profile_name}' not found.")
    return [gr.update()] * 7

########################################################
# 4. UI setup
########################################################

# Define custom CSS styles for the Gradio interface
custom_css = """
.gradio-container {
    max-width: 1200px !important;
    font-family: Arial, sans-serif;
    font-size: 14px;
}
.output-image, .input-image {
    height: 600px !important;
}
.center {
    text-align: center;
}
.app-header {
    font-family: Arial, sans-serif;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px 0;
    background-color: #f9fafb;
    border-bottom: 1px solid #ffcc99;
}
.app-header h1 {
    font-size: 28px;
    color: #ff6600;
    margin-bottom: 10px;
}
.app-header p {
    font-size: 16px;
    color: #ff9933;
    max-width: 800px;
    margin: 0 auto;
    text-align: center;
}
.app-footer {
    font-family: Arial, sans-serif;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px 0;
    background-color: #f9fafb;
    border-top: 1px solid #ffcc99;
    margin-top: 30px;
}
.app-footer p {
    font-size: 14px;
    color: #ff9933;
    max-width: 800px;
    margin: 10px auto;
    text-align: center;
}
.custom-component {
    font-weight: bold;
}
.custom-component:hover {
    background-color: #fdedd6;
    color: white;
}
.custom-button {
    color: #ff9933 !important;
    border-color: #ff9933 !important;
    background-color: white !important;
    font-weight: bold !important;
    transition: all 0.3s ease !important;
}
.custom-button:hover {
    color: white !important;
    background-color: #ff9933 !important;
}
.custom-button:active {
    color: white !important;
    background-color: #5ce65c !important;
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}
.custom-dropdown {
    font-weight: bold;
}

.custom-dropdown:hover {
    background-color: #fdedd6;
    color: white;
}
.custom-slider {
    font-weight: bold;
}
.custom-slider:hover {
    background-color: #fdedd6;
    color: white;
}
"""

custom_theme = gr.themes.Soft(primary_hue="orange", secondary_hue="orange", font=["Arial", "sans-serif"])

########################################################
# 5. Gradio interface
########################################################

with gr.Blocks(css=custom_css, theme=custom_theme) as iface:
    # Title and description
    with gr.Row(elem_classes=["app-header"]):
        gr.Markdown("# Cellpose Gradio")
        gr.Markdown("A Gradio based user-friendly interface for cell segmentation using Cellpose.")
        gr.Markdown("For more complex needs, please use the Cellpose GUI.")
        gr.Markdown("Please refer to the [Cellpose documentation](https://cellpose.readthedocs.io/en/latest/) for more information on the parameters.")
    
    # Input image
    with gr.Row():
        input_image = gr.Image(label="Input Image - Supported formats include TIFF, PNG, and JPEG. - TIFF images preview is not supported.", type="numpy", height=400, width=400, visible=True)

    # Save and load settings
    with gr.Row():
        with gr.Column(scale=1):
            profile_name = gr.Textbox(label="Save your current settings as a profile", placeholder="Enter profile name", info="Name your profile to save the current settings.", elem_classes=["custom-component"])
            save_btn = gr.Button("Save Profile", scale=1, size="sm", elem_classes=["custom-button"])
        with gr.Column(scale=1):
            load_profile = gr.Dropdown(label="Load Profile", choices=list_profiles(), scale=1, info="Select a profile to load its settings.", elem_classes=["custom-dropdown"])
            load_btn = gr.Button("Load Profile", scale=1, size="sm", elem_classes=["custom-button"])    
    
    # Model type, diameter, flow threshold
    with gr.Row():
        model_type = gr.Dropdown(choices=['cyto3', 'cyto2', 'cyto', 'nuclei'], label="Choose segmentation model", value='cyto3', scale=1, info="cyto/cyto2/cyto3: generalist models for cells (channel 1 is cells color and channel 2 is nuclei color), nuclei: specialized for nucleus segmentation.(channel 1 is nuclei color and set channel 2 to 0)", elem_classes=["custom-dropdown"])
        diameter = gr.Slider(minimum=1, maximum=100, step=1,label="Diameter", value=30, scale=1, info="Set the expected diameter of cells in pixels. When the diameter is set smaller than the true size then cellpose may over-split cells. Similarly, if the diameter is set too big then cellpose may over-merge cells.", elem_classes=["custom-slider"])
        flow_threshold = gr.Slider(minimum=0.0, maximum=1.0, step=0.01,label="Flow Threshold", value=0.4, scale=1, info="Adjust the flow threshold (maximum allowed error of the flows for each mask): Increase it if cellpose is not returning as many ROIs as you’d expect. Decrease it if cellpose is returning too many ill-shaped ROIs.", elem_classes=["custom-slider"])
    
    # Display channel, segmentation channels, and color palette
    with gr.Row():
        with gr.Column(scale=2):
            with gr.Group():
                display_channel = gr.Dropdown(
                choices=["RGB", "Grayscale", "Red", "Green", "Blue"],
                label="Displayed Channel",
                    value="RGB",
                    info="The channel used to display the original image after segmentation.",
                    elem_classes=["custom-dropdown"]
                )
                cmap = gr.Dropdown(
                choices=['tab20', 'tab20b', 'tab20c','viridis', 'plasma', 'inferno', 'magma', 'cividis', 'hsv', 'twilight', 'gray'],
                label="Segmentation Masks Color Palette",
                value='tab20b',
                info="The color palette used to display different cells in the segmentation result.",
                elem_classes=["custom-dropdown"]
            )
        with gr.Column(scale=2):
            with gr.Group():
                seg_channel1 = gr.Dropdown(
                    choices=[0, 1, 2, 3],
                    label="Segmentation Channel 1",
                    value=0,
                    info="0=grayscale, 1=red, 2=green, 3=blue",
                    elem_classes=["custom-dropdown"]
                )
                seg_channel2 = gr.Dropdown(
                    choices=[0, 1, 2, 3],
                    label="Segmentation Channel 2",
                    value=0,
                    info="0=None (will set to zero), 1=red, 2=green, 3=blue",
                    elem_classes=["custom-dropdown"]
                )
    
    process_btn = gr.Button("Run Segmentation", scale=2, elem_classes=["custom-button"])

    # Output plot + progress animation
    with gr.Row():
        output_plot = gr.Plot(label="Segmentation Results")
        progress_output = gr.Textbox(label="Progress", interactive=False, visible=False)
    
    # Output files and cell count
    with gr.Row():
        cell_count_output = gr.Number(label="Number of cells detected", scale=1, elem_classes=["custom-component"])
        output_files = gr.File(label="Download Results (date and time is in the filename)", file_count="multiple", scale=1, elem_classes=["custom-component"])
    
    # buttons logic
    
    # Run segmentation button
    process_btn.click(
        fn=process_and_display,
        inputs=[input_image, model_type, diameter, flow_threshold, display_channel, seg_channel1, seg_channel2, cmap],
        outputs=[output_plot, output_files, cell_count_output, progress_output]
    )
    
    # Save settings button
    save_btn.click(
        save_settings,
        inputs=[profile_name, model_type, diameter, flow_threshold, display_channel, seg_channel1, seg_channel2, cmap],
        outputs=[load_profile]  # Update the load_profile dropdown
    )

    # Load settings button
    load_btn.click(
        load_settings,
        inputs=[load_profile],
        outputs=[model_type, diameter, flow_threshold, display_channel, seg_channel1, seg_channel2, cmap]
    )

    # Footer
    with gr.Row(elem_classes=["app-footer"]):
        gr.Markdown("This app is based on Cellpose, a software for cell segmentation in microscopy images. For more information, see the [Cellpose Github repository](https://github.com/Cellpose/Cellpose).")
        gr.Markdown("If you find this app useful, please cite the [Cellpose3 paper](https://www.biorxiv.org/content/10.1101/2024.02.10.579780v1).")
        gr.Markdown("If you have any issues or feedback, please open an issue on the [Github Cellpose-gradio repository](https://github.com/LSeu-Open/cellpose-gradio).")

########################################################
# 6. Launch the interface
########################################################

if __name__ == "__main__":
    iface.launch()
